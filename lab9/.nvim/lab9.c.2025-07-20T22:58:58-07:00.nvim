/*
1. What is the address of the server it is trying to connect to (IP address and port number).
   IP address: 127.0.0.1 (localhost), Port: 8000. Lines 10 and 8 define ADDR as "127.0.0.1" and PORT as 8000

2. Is it UDP or TCP? How do you know?
   TCP. Line 23 uses SOCK_STREAM which indicates TCP. UDP would use SOCK_DGRAM.

3. The client is going to send some data to the server. Where does it get this data from? How can you tell in the code?
   The data comes from standard input (keyboard/terminal input), Line 38 reads from STDIN_FILENO, which means it reads from standard input

4. How does the client program end? How can you tell that in the code?
   The client ends when EOF is encountered on standard input (when user presses Ctrl+D or input ends). Line 38 shows the while loop continues while read() returns > 1. When EOF is reached, read() returns 0 or -1, breaking the loop and leading to program termination
*/

#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define PORT 8000
#define BUF_SIZE 64
#define ADDR "127.0.0.1"

#define handle_error(msg)                                                      \
  do {                                                                         \
    perror(msg);                                                               \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

int main() {
  struct sockaddr_in addr;
  int sfd;
  ssize_t num_read;
  char buf[BUF_SIZE];

  sfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sfd == -1) {
    handle_error("socket");
  }

  memset(&addr, 0, sizeof(struct sockaddr_in));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(PORT);
  if (inet_pton(AF_INET, ADDR, &addr.sin_addr) <= 0) {
    handle_error("inet_pton");
  }

  int res = connect(sfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in));
  if (res == -1) {
    handle_error("connect");
  }

  while ((num_read = read(STDIN_FILENO, buf, BUF_SIZE)) > 1) {
    if (write(sfd, buf, num_read) != num_read) {
      handle_error("write");
    }
    printf("Just sent %zd bytes.\n", num_read);
  }

  if (num_read == -1) {
    handle_error("read");
  }

  close(sfd);
  exit(EXIT_SUCCESS);
}

#include <arpa/inet.h>
#include <errno.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

#define BUF_SIZE 64
#define PORT 8000
#define LISTEN_BACKLOG 32

#define handle_error(msg)                                                      \
  do {                                                                         \
    perror(msg);                                                               \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

// Shared counters for: total # messages, and counter of clients (used for
// assigning client IDs)
int total_message_count = 0;
int client_id_counter = 1;

// Mutexs to protect above global state.
pthread_mutex_t count_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t client_id_mutex = PTHREAD_MUTEX_INITIALIZER;

struct client_info {
  int cfd;
  int client_id;
};

void *handle_client(void *arg) {
  struct client_info *client = (struct client_info *)arg;
  char buf[BUF_SIZE];
  ssize_t num_read;

  // Read messages from the client
  while ((num_read = read(client->cfd, buf, BUF_SIZE - 1)) > 0) {
    // Null-terminate the buffer
    buf[num_read] = '\0';
    
    // Remove trailing newline if present
    if (num_read > 0 && buf[num_read - 1] == '\n') {
      buf[num_read - 1] = '\0';
      num_read--;
    }
    
    // Skip empty messages
    if (num_read > 0) {
      // Thread-safe increment of total message count
      pthread_mutex_lock(&count_mutex);
      total_message_count++;
      int current_count = total_message_count;
      pthread_mutex_unlock(&count_mutex);

      // Print the received message
      printf("Msg #%4d; Client ID %d: %s\n", current_count, client->client_id, buf);
    }
  }

  // Close the client socket
  close(client->cfd);
  printf("Ending thread for client %d\n", client->client_id);
  
  // Free the client info structure
  free(client);

  return NULL;
}

int main() {
  struct sockaddr_in addr;
  int sfd;

  sfd = socket(AF_INET, SOCK_STREAM, 0);
  if (sfd == -1) {
    handle_error("socket");
  }

  memset(&addr, 0, sizeof(struct sockaddr_in));
  addr.sin_family = AF_INET;
  addr.sin_port = htons(PORT);
  addr.sin_addr.s_addr = htonl(INADDR_ANY);

  if (bind(sfd, (struct sockaddr *)&addr, sizeof(struct sockaddr_in)) == -1) {
    handle_error("bind");
  }

  if (listen(sfd, LISTEN_BACKLOG) == -1) {
    handle_error("listen");
  }

  for (;;) {
    // Accept a new client connection
    int cfd = accept(sfd, NULL, NULL);
    if (cfd == -1) {
      handle_error("accept");
    }

    // Create a new client info structure
    struct client_info *client = malloc(sizeof(struct client_info));
    if (client == NULL) {
      handle_error("malloc");
    }

    // Assign client ID in a thread-safe manner
    pthread_mutex_lock(&client_id_mutex);
    client->client_id = client_id_counter++;
    pthread_mutex_unlock(&client_id_mutex);
    
    client->cfd = cfd;

    // Print new client message
    printf("New client created! ID %d on socket FD %d\n", client->client_id, cfd);

    // Create a new thread to handle this client
    pthread_t thread;
    if (pthread_create(&thread, NULL, handle_client, client) != 0) {
      handle_error("pthread_create");
    }

    // Detach the thread so it cleans up automatically when it finishes
    if (pthread_detach(thread) != 0) {
      handle_error("pthread_detach");
    }
  }

  if (close(sfd) == -1) {
    handle_error("close");
  }

  return 0;
}

